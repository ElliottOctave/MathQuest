<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Math Harvest VR</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.161.0/build/three.module.js';
    import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.161.0/examples/jsm/webxr/VRButton.js';
    import { Sky } from './Sky.js';
    import { GLTFLoader } from './GLFT.js';

    let camera, scene, renderer;
    let controller, raycaster, tempMatrix, grabbedApple = null;
    const apples = [];
    let applesInBasket = 0;
    const fallingApples = [];
    const gravity = -0.01;
    let basket, appleCounter;
    let correctAnswer;

    init();
    animate();

    function init() {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(0, 1.6, 3);

      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      renderer.shadowMap.enabled = true;
      document.body.appendChild(renderer.domElement);
      document.body.appendChild(VRButton.createButton(renderer));

      raycaster = new THREE.Raycaster();
      tempMatrix = new THREE.Matrix4();

      const sky = new Sky();
      sky.scale.setScalar(450000);
      scene.add(sky);
      const skyUniforms = sky.material.uniforms;
      skyUniforms['turbidity'].value = 10;
      skyUniforms['rayleigh'].value = 2;
      skyUniforms['mieCoefficient'].value = 0.005;
      skyUniforms['mieDirectionalG'].value = 0.8;
      skyUniforms['sunPosition'].value.setFromSphericalCoords(1, Math.PI / 4, Math.PI / 4);

      const sunLight = new THREE.DirectionalLight(0xffffff, 1);
      sunLight.position.set(10, 20, 10);
      sunLight.castShadow = true;
      scene.add(sunLight);

      const textureLoader = new THREE.TextureLoader();
      const grassTexture = textureLoader.load('https://threejs.org/examples/textures/terrain/grasslight-big.jpg');
      grassTexture.wrapS = grassTexture.wrapT = THREE.RepeatWrapping;
      grassTexture.repeat.set(25, 25);

      const floor = new THREE.Mesh(
        new THREE.PlaneGeometry(50, 50),
        new THREE.MeshStandardMaterial({ map: grassTexture })
      );
      floor.rotation.x = -Math.PI / 2;
      floor.receiveShadow = true;
      scene.add(floor);

      correctAnswer = createEquationPanel();
      appleCounter = createAppleCounterPanel();

      // Replace the random tree loop with 5 explicitly placed trees and apples
// Each tree will have leaves and apples placed on the visible (front) side

// Replace the random tree loop with 5 explicitly placed trees and apples in an arc shape
// Each tree will have leaves and apples placed only on the front (user-facing) side

const trunkHeight = 1.2;
const leafMaterial = new THREE.MeshStandardMaterial({ color: '#3DAE2B' });
const leafCenters = [];

const arcCenter = new THREE.Vector3(0, 0, -2);
const arcRadius = 2.5;
const treeCount = 5;
const treeAngles = [-Math.PI / 4, -Math.PI / 8, 0, Math.PI / 8, Math.PI / 4];

const appleLoader = new GLTFLoader();
appleLoader.load('apple.glb', (gltf) => {
  const appleModel = gltf.scene;

  treeAngles.forEach((angle, index) => {
    const x = arcCenter.x + arcRadius * Math.sin(angle);
    const z = arcCenter.z - arcRadius * Math.cos(angle);

    // Tree trunk
    const trunk = new THREE.Mesh(
      new THREE.CylinderGeometry(0.1, 0.15, trunkHeight, 12),
      new THREE.MeshStandardMaterial({ color: '#8B4513' })
    );
    trunk.position.set(x, trunkHeight / 2, z);
    trunk.castShadow = true;
    scene.add(trunk);

    // Leaves (front facing, consistent placement)
    const leaf1 = new THREE.Mesh(
      new THREE.SphereGeometry(0.6, 16, 16),
      leafMaterial
    );
    leaf1.position.set(x, trunkHeight + 0.4, z);
    leaf1.castShadow = true;
    scene.add(leaf1);
    leafCenters.push({ center: leaf1.position.clone(), radius: 0.6 });

    const leaf2 = new THREE.Mesh(
      new THREE.SphereGeometry(0.5, 16, 16),
      leafMaterial
    );
    leaf2.position.set(x - 0.3, trunkHeight + 0.1, z);
    leaf2.castShadow = false;
    scene.add(leaf2);
    leafCenters.push({ center: leaf2.position.clone(), radius: 0.5 });

    // Add 10 apples on front side facing the basket
    const applesPerLeaf = 2;
const totalApples = applesPerLeaf * 2;

for (let i = 0; i < totalApples; i++) {
  const leafIndex = i < applesPerLeaf ? leafCenters.length - 1 : leafCenters.length - 2;
  const { center, radius } = leafCenters[leafIndex];

  // Spread only across the front hemisphere
  const theta = THREE.MathUtils.degToRad(THREE.MathUtils.randFloat(60, 120)); // Yaw: Â±30Â° from front
  const phi = THREE.MathUtils.degToRad(THREE.MathUtils.randFloat(70, 100));   // Elevation: around equator

  const x = center.x + radius * Math.sin(phi) * Math.cos(theta);
  const y = center.y + radius * Math.cos(phi);
  const z = center.z + radius * Math.sin(phi) * Math.sin(theta);

  const apple = appleModel.clone();
  apple.scale.set(0.002, 0.002, 0.002);
  apple.position.set(x, y, z);
  apple.userData.isApple = true;

  apple.traverse(child => {
    if (child.isMesh) {
      child.castShadow = true;
      child.receiveShadow = false;
      child.geometry.computeBoundingBox(); // ðŸ‘ˆ ensures raycasting works properly
    }
  });

  apples.push(apple);
  scene.add(apple);
}

  });
});

     

      const basketProfile = [
        new THREE.Vector2(0.0, 0.0),
        new THREE.Vector2(0.15, 0.0),
        new THREE.Vector2(0.17, 0.05),
        new THREE.Vector2(0.20, 0.10),
        new THREE.Vector2(0.24, 0.15),
        new THREE.Vector2(0.28, 0.20),
        new THREE.Vector2(0.30, 0.25)
      ];

      const basketGeometry = new THREE.LatheGeometry(basketProfile, 64);
      const basketMaterial = new THREE.MeshStandardMaterial({
        color: 0xA0522D,
        roughness: 0.85,
        metalness: 0.05,
        side: THREE.DoubleSide
      });

      basket = new THREE.Mesh(basketGeometry, basketMaterial);
      basket.scale.set(1.5, 1.5, 1.5);
      basket.position.set(0, 0.0, -2);
      basket.castShadow = true;
      basket.receiveShadow = false;
      scene.add(basket);

      controller = renderer.xr.getController(0);
      controller.addEventListener('selectstart', onSelectStart);
      controller.addEventListener('selectend', onSelectEnd);
      scene.add(controller);

      const controllerRay = new THREE.Mesh(
        new THREE.CylinderGeometry(0.005, 0.005, 1, 32),
        new THREE.MeshBasicMaterial({ color: 0xffff00 })
      );
      controllerRay.rotation.x = -Math.PI / 2;
      controllerRay.position.z = -0.5;
      controller.add(controllerRay);

      window.addEventListener('resize', onWindowResize);
    }

    function createEquationPanel() {
      const num1 = Math.floor(Math.random() * 6) + 1;
      const num2 = Math.floor(Math.random() * (10 - num1)) + 1;
      const sum = num1 + num2;

      const canvas = document.createElement('canvas');
      canvas.width = 1024;
      canvas.height = 256;
      const ctx = canvas.getContext('2d');

      ctx.fillStyle = '#114477';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.strokeStyle = '#FFFFFF';
      ctx.lineWidth = 12;
      ctx.strokeRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = '#FFF';
      ctx.font = 'bold 96px Comic Sans MS';
      ctx.textAlign = 'center';
      ctx.fillText(`${num1} + ${num2} = ?`, canvas.width / 2, canvas.height / 2 + 32);

      const texture = new THREE.CanvasTexture(canvas);
      const material = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true });
      const panel = new THREE.Mesh(new THREE.PlaneGeometry(2.5, 0.8), material);
      panel.position.set(0, 3, -1.5);
      scene.add(panel);

      return sum;
    }

    function createAppleCounterPanel() {
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 128;
      const ctx = canvas.getContext('2d');

      ctx.fillStyle = '#333';
      ctx.fillRect(0, 0, 512, 128);
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 48px Arial';
      ctx.textAlign = 'center';
      ctx.fillText('ðŸŽ 0', 256, 80);

      const texture = new THREE.CanvasTexture(canvas);
      const panel = new THREE.Mesh(
        new THREE.PlaneGeometry(1.2, 0.3),
        new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide })
      );
      panel.position.set(0.8, 1.4, -2.1);
      scene.add(panel);

      return { texture, ctx, panel };
    }

    function updateCounterDisplay() {
      const ctx = appleCounter.ctx;
      ctx.clearRect(0, 0, 512, 128);
      ctx.fillStyle = '#333';
      ctx.fillRect(0, 0, 512, 128);
      ctx.fillStyle = '#FFD700';
      ctx.font = 'bold 48px Arial';
      ctx.textAlign = 'center';
      ctx.fillText(`ðŸŽ ${applesInBasket}`, 256, 80);
      appleCounter.texture.needsUpdate = true;
    }

    function onSelectStart() {
  if (grabbedApple) return;

  tempMatrix.identity().extractRotation(controller.matrixWorld);
  raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
  raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

  const intersects = raycaster.intersectObjects(apples, true); // recursive
  console.log("Ray hits:", intersects);

  for (const hit of intersects) {
    let obj = hit.object;

    // Walk up the parent chain to find the root apple
    while (obj && !obj.userData.isApple && obj.parent) {
      obj = obj.parent;
    }

    if (obj && obj.userData.isApple && !obj.userData.isFalling) {
      grabbedApple = obj;

      const worldPosition = new THREE.Vector3();
      grabbedApple.getWorldPosition(worldPosition);

      controller.attach(grabbedApple);
      grabbedApple.position.copy(controller.worldToLocal(worldPosition.clone()));
      break;
    }
  }
}

function onSelectEnd() {
  if (grabbedApple) {
    // Mark as falling and add to falling list
    grabbedApple.userData.isFalling = true;
    fallingApples.push({
      mesh: grabbedApple,
      velocity: new THREE.Vector3(0, 0, 0)
    });

    // Detach from controller
    scene.attach(grabbedApple);
    grabbedApple = null;
  }
}



    function checkAnswer() {
      updateCounterDisplay();
      if (applesInBasket === correctAnswer) alert('âœ… Correct!');
      else if (applesInBasket > correctAnswer) alert('âŒ Too many apples!');
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
  renderer.setAnimationLoop(() => {
    // ðŸ›‘ Removed unnecessary grabbedApple.position.setFromMatrixPosition

    // ðŸŽ Handle falling apples with gravity
    for (let i = fallingApples.length - 1; i >= 0; i--) {
      const obj = fallingApples[i];
      obj.velocity.y -= 0.00098; // gravity
      obj.mesh.position.add(obj.velocity);

      // Ground collision
      if (obj.mesh.position.y <= 0.02) {
        obj.mesh.position.y = 0.02;
        obj.velocity.set(0, 0, 0);
        obj.mesh.userData.isFalling = false;
        fallingApples.splice(i, 1);
      }

      // Basket check
      const distance = obj.mesh.position.distanceTo(basket.position);
      if (distance < 0.4) {
        scene.remove(obj.mesh);
        applesInBasket++;
        updateCounterDisplay();
        checkAnswer();
        fallingApples.splice(i, 1);
      }
    }

    renderer.render(scene, camera);
  });
}

  </script>
</body>
</html>
